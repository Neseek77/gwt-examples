#summary Reading and Writing to the Google App Engine Datastore

<wiki:gadget url="http://gwt-examples.googlecode.com/svn/trunk/DemoGadgetXml/war/gadget-gwt-examples-ads-v2-atf.xml" height="110" width="760" border="0" />

= Writing in progress... =
  I'm putting stuff together to put in here. Should be up over the weekend.

 * [DemoGAEMultiFileBlobUpload] - Notes about blobbing


== Glimpse Into My Chunking Experiment ==
 I am chunking base64 from GWT client into the blobstore and decoding and writing on the fly.

{{{
import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.jdo.annotations.NotPersistent;

import org.gonevertical.core.client.ui.admin.blobs.BlobData;
import org.gonevertical.core.client.ui.admin.blobs.FileByteData;
import org.gonevertical.core.client.ui.admin.blobs.file.FileData;
import org.gonevertical.core.client.ui.admin.thingstuff.ThingStuffData;
import org.gonevertical.core.client.ui.admin.thingstufftype.ThingStuffTypeData;
import org.gonevertical.core.client.ui.admin.thingtype.ThingTypeData;
import org.gonevertical.core.server.ServerPersistence;
import org.gonevertical.core.server.db.Db_Thing;
import org.gonevertical.core.server.jdo.data.BlobTmpJdo;
import org.gonevertical.core.server.jdo.data.ThingStuffJdo;

import com.google.appengine.api.blobstore.BlobKey;
import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.PreparedQuery;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.datastore.Text;
import com.google.appengine.api.datastore.Query.FilterOperator;
import com.google.appengine.api.datastore.Query.SortDirection;
import com.google.appengine.api.files.AppEngineFile;
import com.google.appengine.api.files.FileService;
import com.google.appengine.api.files.FileServiceFactory;
import com.google.appengine.api.files.FileWriteChannel;
import com.google.appengine.api.files.FinalizationException;
import com.google.appengine.api.files.LockException;

public class WriteBase64 {
  
  private final char[] BASE64ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();

  private int[] toInt = new int[128];

  private static final Logger log = Logger.getLogger(WriteBase64.class.getName());
  
  private ServerPersistence sp;

  private FileByteData fbd;

  private AppEngineFile file;

  private FileWriteChannel writeChannel;

  private long newFileThingId;

  private FileService fileService;

  private long newfileThingId;

  public WriteBase64(ServerPersistence sp) {
    this.sp = sp;
    
    for (int i=0; i < BASE64ALPHA.length; i++){
      toInt[BASE64ALPHA[i]] = i;
    }
  }
  
  public void decodeToBlob(FileByteData fbd) {
    this.fbd = fbd;
    
    initBlobWrite();
    
    query();
    
    close();
  }
  
  public long getThingId() {
    return newFileThingId;
  }
  
  private void close() {
    try {
      writeChannel.closeFinally();
    } catch (IllegalStateException e) {
      log.severe("close(): Error 6:" + e.toString());
      e.printStackTrace();
    } catch (IOException e) {
      log.severe("close(): Error 7:" + e.toString());
      e.printStackTrace();
    }
    
    BlobKey blobKey = fileService.getBlobKey(file);
    
    if (blobKey == null) {
      // TODO apply workaround by finding the filename
      return;
    }
    
    // save to my db
    //...
  }

  private void initBlobWrite() {
    fileService = FileServiceFactory.getFileService();
    try {
      file = fileService.createNewBlobFile(fbd.getContentType(), fbd.getFileName());
    } catch (IOException e) {
      log.severe("initBlobWrite(): Error 1:" + e.toString());
      e.printStackTrace();
    }
    
    boolean lock = true;
    try {
      writeChannel = fileService.openWriteChannel(file, lock);
    } catch (FileNotFoundException e) {
      log.severe("initBlobWrite(): Error 2:" + e.toString());
      e.printStackTrace();
    } catch (FinalizationException e) {
      log.severe("initBlobWrite(): Error 2.5:" + e.toString());
      e.printStackTrace();
    } catch (LockException e) {
      log.severe("initBlobWrite(): Error 3:" + e.toString());
      e.printStackTrace();
    } catch (IOException e) {
      log.severe("initBlobWrite(): Error 4:" + e.toString());
      e.printStackTrace();
    }
  }
  
  /**
   * query the chunks, start to middle chunks must be divisible by 4, except end
   * 
   * @return
   */
  private boolean query() {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    try {
      Query q = new Query("BlobTmpJdo");
      q.addFilter("key", FilterOperator.EQUAL, fbd.getKey());
      q.addSort("index");
      PreparedQuery e = datastore.prepare(q);
      Iterator<Entity> itr = e.asIterator();
      while (itr.hasNext()) {
        Entity entity = itr.next();
        Text tb64 = (Text) entity.getProperty("base64");
        if (tb64 != null) {
          String b64 = tb64.getValue();
          log.info("query(): index=" + entity.getProperty("index") + " base64=" + tb64.getValue());
          decode(b64);
        } else {
          // TODO
          log.info("query(): index=" + entity.getProperty("index") + " base64=" + tb64);
        }
      }
    } catch (Exception e) {
      log.log(Level.SEVERE, "", e);
      e.printStackTrace();
    } 
    return true;
  }

  private void decode(String b64) {
    
    ByteArrayOutputStream out = null;
    int mask = 0xFF;
    int index = 0;
    
    for (int i=0; i < b64.length(); i+=4) {
      if (out == null) {
        out = new ByteArrayOutputStream();
      }
      
      int c0 = toInt[b64.charAt(i)]; // char 1
      int c1 = toInt[b64.charAt(i + 1)]; // char 2
      
      byte b1 = (byte) (((c0 << 2) | (c1 >> 4)) & mask);
      out.write(b1);
      
      index++;
      if (index >= b64.length()) {
        break;
      }
      
      int c2 = toInt[b64.charAt(i + 2)]; // char 3
      byte b2 = (byte) (((c1 << 4) | (c2 >> 2)) & mask);
      out.write(b2);
      
      index++;
      if (index >= b64.length()) {
        break;
      }
      
      int c3 = toInt[b64.charAt(i + 3)]; // char 4
      byte b3 = (byte) (((c2 << 6) | c3) & mask);
      out.write(b3);
    }
    
    if (out != null) {
      writeToBlob(out);
    }
  }

  private void writeToBlob(ByteArrayOutputStream out) {
    ByteBuffer bb = ByteBuffer.wrap(out.toByteArray());
    try {
      writeChannel.write(bb);
    } catch (IOException e) {
      log.severe("writeToBlob(): Error 5:" + e.toString());
      e.printStackTrace();
    }
  }
  
}
}}}