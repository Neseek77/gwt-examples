#summary My GWT HTML5 notes

<wiki:gadget url="http://gwt-examples.googlecode.com/svn/trunk/DemoGadgetXml/war/gadget-gwt-examples-ads-v2-atf.xml" height="95" width="735" border="0" />


= HTML5 and GWT =
 I'm going to write down my HTML5 stuff here. I'm in love with the HTML5 stuff!!!!!!
 * [http://www.w3.org/TR/2dcontext/#canvasrenderingcontext2d HTML5 Canvas Specs] 

== Image Scale / Resize ==
 I had trouble scaling an image in app engine and HTML5 canvas has so many more options and fun things to work with. The canvas uses the imageElement, which you can get from GWT Image. Note you have to use a load handler before you can work with the Image.

 Scale an image like this:
{{{
private Canvas canvasScreen;
private Context2d contextScreen;

public void onModuleLoad() {
    canvasScreen = Canvas.createIfSupported();
     
    if (canvasScreen == null) {
      RootPanel.get().add(new Label("Sorry, your browser doesn't support the HTML5 Canvas element"));
      return;
    }
    // for example
    canvasScreen.setCoordinateSpaceHeight(1000);
    canvasScreen.setCoordinateSpaceWidth(1000);
    
    contextScreen = canvasScreen.getContext2d();
    RootPanel.get().add(canvasScreen);
   
   loadImage();
}

// This is important to use a handler!
private void loadImage() {
    final Image img = new Image("/images/test.jpg");
    RootPanel.get().add(img);
    img.setVisible(false);
    
    img.addLoadHandler(new LoadHandler() {
      public void onLoad(LoadEvent event) {
        scale(img);
      }
    });
}

private void scale(Image img) {
    ImageData imageData = scaleImage(img, .1);
    
    drawToScreen(imageData);
}

private ImageData scaleImage(Image image, double scaleToRatio) {
    
    Canvas canvasTmp = Canvas.createIfSupported();
    Context2d context = canvasTmp.getContext2d();

    canvasTmp.setCoordinateSpaceHeight((int) (image.getHeight() * scaleToRatio));
    canvasTmp.setCoordinateSpaceWidth((int) (image.getWidth() * scaleToRatio));
    
    ImageElement imageElement = ImageElement.as(image.getElement());
   
    // s = source
    // d = destination 
    double sx = 0;
    double sy = 0;
    double sw = imageElement.getWidth();
    double sh = imageElement.getHeight();
    
    double dx = 0;
    double dy = 0;
    double dw = imageElement.getWidth();
    double dh = imageElement.getHeight();
    
    // tell it to scale image
    context.scale(scaleToRatio, scaleToRatio);
    
    // draw image to canvas
    context.drawImage(imageElement, sx, sy, sw, sh, dx, dy, dw, dh);
    
    // get image data
    double w = dw * scaleToRatio;
    double h = dh * scaleToRatio;
    ImageData imageData = context.getImageData(0, 0, w, h);

    return imageData;
}
}}}

== Crop Image ==
 Crop an Image using the canvas element. Look at the scaling example for the image handler.
{{{
private ImageData cropImage(Image image, double sx, double sy, double sw, double sh) {
    
    Canvas canvasTmp = Canvas.createIfSupported();
    //RootPanel.get().add(canvasTmp); // debug it
    Context2d context = canvasTmp.getContext2d();

    canvasTmp.setCoordinateSpaceHeight((int) sh);
    canvasTmp.setCoordinateSpaceWidth((int) sw);
    
    ImageElement imageElement = ImageElement.as(image.getElement());
   
    double dx = 0;
    double dy = 0;
    double dw = sw;
    double dh = sh;
    
    // draw image to canvas
    context.drawImage(imageElement, sx, sy, sw, sh, dx, dy, dw, dh);
    
    // get image data
    double w = sw;
    double h = sh;
    ImageData imageData = context.getImageData(0, 0, w, h);

    return imageData;
}
}}}

== Scale and Crop ==
 Scale and crop in one method. Use a load handler like the first example on this page.
{{{
private ImageData scaleAndCropImage(Image image, double scaleToRatio, double sx, double sy, double sw, double sh) {
    
    Canvas canvasTmp = Canvas.createIfSupported();
    //RootPanel.get().add(canvasTmp);
    Context2d context = canvasTmp.getContext2d();

    canvasTmp.setCoordinateSpaceHeight((int) (image.getHeight() * scaleToRatio));
    canvasTmp.setCoordinateSpaceWidth((int) (image.getWidth() * scaleToRatio));
    
    ImageElement imageElement = ImageElement.as(image.getElement());

    // tell it to scale image
    context.scale(scaleToRatio, scaleToRatio);
    
    // draw image to canvas
    // s = source
    // d = destination     
    double dx = 0;
    double dy = 0;
    context.drawImage(imageElement, dx, dy);
    
    // get image data - if you go greater than the scaled image nothing will show up
    ImageData imageData = context.getImageData(sx, sy, sw, sh);

    return imageData;
}
}}}

== Test Canvase Base64 Mime Decoding ==
 Getting the imagedata canvase.toDataUrl("image/png") is encoded in base 64 Mime format. Here is one test I used to see if I was doing things correctly.

{{{
    // I manually retrieved the base64 string and removed the first part up to the comma.
    // base64 = canvasTmp.toDataUrl("image/png"); // base64 Mime format
    String base64 = "iVBORw0KGgoAAAANSUhEUgA...="; //canvas.toDataUrl("image/png");
    
    byte[] b = Base64Util.decode(base64);

    String s = new String(b);
   
    String path = "/Users/branflake2267/Downloads/test_coder.png";
    File file = new File(path);
    try {
      BufferedWriter out = new BufferedWriter(new FileWriter(file));
      out.write(s);
      out.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
}}}
 Base64 encode and decoder - I can't remember were I found this.
{{{
public class Base64Util {
  private final static char[] ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray();

  private static int[]  toInt   = new int[128];

  static {
    for(int i=0; i< ALPHABET.length; i++){
      toInt[ALPHABET[i]]= i;
    }
  }

  /**
   * Translates the specified byte array into Base64 string.
   *
   * @param buf the byte array (not null)
   * @return the translated Base64 string (not null)
   */
  public static String encode(byte[] buf){
    int size = buf.length;
    char[] ar = new char[((size + 2) / 3) * 4];
    int a = 0;
    int i=0;
    while(i < size){
      byte b0 = buf[i++];
      byte b1 = (i < size) ? buf[i++] : 0;
      byte b2 = (i < size) ? buf[i++] : 0;
      int mask = 0x3F;
      ar[a++] = ALPHABET[(b0 >> 2) & mask];
      ar[a++] = ALPHABET[((b0 << 4) | ((b1 & 0xFF) >> 4)) & mask];
      ar[a++] = ALPHABET[((b1 << 2) | ((b2 & 0xFF) >> 6)) & mask];
      ar[a++] = ALPHABET[b2 & mask];
    }
    switch(size % 3){
    case 1: ar[--a]  = '=';
    case 2: ar[--a]  = '=';
    }
    return new String(ar);
  }

  /**
   * Translates the specified Base64 string into a byte array.
   *
   * @param s the Base64 string (not null)
   * @return the byte array (not null)
   */
  public static byte[] decode(String s){
    int delta = s.endsWith( "==" ) ? 2 : s.endsWith( "=" ) ? 1 : 0;
    byte[] buffer = new byte[s.length()*3/4 - delta];
    int mask = 0xFF;
    int index = 0;
    for(int i=0; i< s.length(); i+=4){
      int c0 = toInt[s.charAt( i )];
      int c1 = toInt[s.charAt( i + 1)];
      buffer[index++]= (byte)(((c0 << 2) | (c1 >> 4)) & mask);
      if(index >= buffer.length){
        return buffer;
      }
      int c2 = toInt[s.charAt( i + 2)];
      buffer[index++]= (byte)(((c1 << 4) | (c2 >> 2)) & mask);
      if(index >= buffer.length){
        return buffer;
      }
      int c3 = toInt[s.charAt( i + 3 )];
      buffer[index++]= (byte)(((c2 << 6) | c3) & mask);
    }
    return buffer;
  } 

}
}}}

