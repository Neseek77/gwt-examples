#summary Quick Tips about how things work

= Quick Tips =
 Quick tips that might help you. These are things that I have learned along the way that make my job easier.

== Console/Syslog Debugging ==
 Using System.out.println to print to debugger console or when running it on the server it will print to the /var/log/Syslog which is very helpful for debugging.
{{{
System.out.println("MyMethod has this var: " + this.MyVar);
}}}

== Print RPCs Serialized Response ==
 I found this in GWT sample Dynamic Table. I love this function b/c it prints out the object that will be sent in the RPC. Put this snippet in your server side of the rpc call, MyServerImpl.java class. 
{{{
//stick this in your server side, MyServiceImpl.java class
/**
 * Write the serialized response out to stdout. This is a very unusual thing
 * to do, but it allows us to create a static file version of the response
 * without deploying a servlet.
 */
protected void onAfterResponseSerialized(String serializedResponse) {
  System.out.println(serializedResponse);
}
}}}

== Image ==
 Show an external image on your page.
{{{
//stick the image in the ~/www folder
HorizontalPanel pLoading = new HorizontalPanel();
String sImage = GWT.getModuleBaseURL() + "loading2.gif";
Image image = new Image(sImage);
pLoading.add(image);
}}}

== String Comparison ==
 You can compare strings like this.
{{{
//myString.equals(OtherString) is boolean

//init all strings = "" if using ".equals"!
String myString = "";

//like (this == that)
if (myString.equals(myOtherString)) {
    //do this
}

//like (this != nothing)
if (myString.equals(null) == false) {
    //do this
}

//like (this != nothing)
if (myString.equals("") == false) {
    //do this
}
}}}

== Clicklistener ==
 Avoid calling a listener more than once! Add the clicklistener in the constructor of the widget not a method called over and over. Every time you call a method with a clicklister, you add another observer to that object. Then if you want to do something with that object, you may cause multiples of something to happen, which is annoying!
{{{
private HorizontalPanel pWidgetContent = new HorizontalPanel();
private PushButton bPushMe = new PushButton("Push Me");
/**
 * constructor - init a widget maybe
 */
public MyClass() {
  initWidget(pWidgetContent);
  bPushMe.addClickListener(this);
}

public void drawMorePanelsEveryOnceInWhile() {
  //don't stick listener here
  //bPushMe.addClickListener(this);
}

public void myMethod() {
  //do something
}

public void onClick(Widget sender) {
  if (sender == bPushMe) {
     this.myMethod();
  }
}
}}}

== Keyboardlistener ==
 * Example of a keyboard listener. Listen to ten key or number pad with numlock on.
 * [http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/user/client/ui/KeyboardListener.html GWT Interface KeyboardListener Reference]
 * Google Example on the [http://google-web-toolkit.googlecode.com/svn/javadoc/1.4/com/google/gwt/user/client/ui/TextBox.html  Textbox]
{{{
public class CalculatorWidget extends Composite implements ClickListener, KeyboardListener {
        TextBox tbDisplay = new TextBox();

   	public CalculatorWidget() {

		//listen to display
		tbDisplay.addKeyboardListener(this);

                RootPanel.get().add(tbDisplay);
	}


public void onClick(Widget sender) {
	}
	
	public void onKeyDown(Widget sender, char keyCode, int modifiers) {
	}
	
	public void onKeyPress(Widget sender, char keyCode, int modifiers) {
	
		RootPanel.get().add(new Label("key pressed: " + keyCode + " modifier: " + modifiers));
		
		switch (keyCode) {
		case KeyboardListener.KEY_ALT: 
			break;
		case KeyboardListener.KEY_BACKSPACE:
			break;
		case KeyboardListener.KEY_CTRL:
			break;
		case KeyboardListener.KEY_DELETE:
			break;
		case KeyboardListener.KEY_DOWN:
			break;
		case KeyboardListener.KEY_END:
			break;
		case KeyboardListener.KEY_ENTER:
			break;
		case KeyboardListener.KEY_ESCAPE:
			break;
		case KeyboardListener.KEY_HOME:
			break;
		case KeyboardListener.KEY_LEFT:
			break;
		case KeyboardListener.KEY_PAGEDOWN:
			break;
		case KeyboardListener.KEY_PAGEUP:
			break;
		case KeyboardListener.KEY_RIGHT:
			break;
		case KeyboardListener.KEY_SHIFT:
			break;
		case KeyboardListener.KEY_TAB:
			break;
		case KeyboardListener.KEY_UP:
			break;
		default:
			
			String keyPressed = Character.toString(keyCode);
		
			if (keyPressed.equals("+") & (modifiers == 1) | keyPressed.equals("+")) { // +	
			} else if ((keyPressed.equals("8") & (modifiers == 1)) | keyPressed.equals("*")) { // *
			} else if (keyPressed.equals("-")) { // -
			} else if (keyPressed.equals("/")) { // /
			} else if (Character.isDigit(keyCode)) { //0-9
			} else if (keyPressed.equals("=")) { // =
			} else { //all other characters
				Window.alert("others");
			}

			break;
		}//end case
	}//end onKeyPress
	
	public void onKeyUp(Widget sender, char keyCode, int modifiers) {	
	}
		
	
}
}}}

== Get ListBox Value's Index ==
 Here is a method used to find the value's index, so then you can setSelected for listbox by value. 
{{{
/**
 * get list box value's index
 * @param lb ListBox - what listbox are you looking for value's index
 * @param SelectedValue - what is the value's index your looking for
 * @return
 */
public int getListBoxIndexByValue(ListBox lb, String SelectedValue) {
	
	if (SelectedValue == null) {
		return 0;
	}
	
	for (int i = 0; i < lb.getItemCount(); i++) {
		String CompareValue = lb.getValue(i);
		if (SelectedValue.equals(CompareValue)) {
			return i;
		}
	}
	return 0;
}
}}}

== Get Widget(s) Data In a Panel ==
 Getting Widgets in a panel is a nice way to interact with widgets you make. You can add several widgets into a panel, and get all of them by looping through the widgets in the panel. I make a specific panel to put all my reminder widgets in. Then I gather data and use it elsewhere.
{{{
/**
 * get my reminders
 * @return ReminderData
 */
private ReminderData[] getReminderData() {
	
        //count my reminders i have in the verticalpanel pReminder
	int count = pReminder.getWidgetCount();
	
        //I use ReminderData object to transport my data around
	ReminderData[] reminderData = new ReminderData[count];
	
        //loop through my ReminderWidget(s) in the pReminderPanel
	for (int i=0; i < count; i++) {

                //cast the widget to my ReminderWidget
		ReminderWidget rw = (ReminderWidget) pReminder.getWidget(i);

                //I use a method to gather up the values in the reminder Widget
		reminderData[i] = rw.getReminderData();
	}

        //then I return the values to the next object, and then to rpc
	return reminderData;
}
}}}
